package com.anrsnt.pos

import android.app.Application
import android.os.Bundle
import android.util.Log
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.animateColorAsState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.viewmodel.compose.viewModel
import kotlinx.coroutines.launch

// Custom Imports
import com.anrsnt.pos.data.Category
import com.anrsnt.pos.data.MenuItem
import com.anrsnt.pos.data.Table
import com.anrsnt.pos.data.AppDatabase
import com.anrsnt.pos.MenuRepository
import com.anrsnt.pos.data.OrderItemRequest
import com.anrsnt.pos.data.OrderRequest
import com.anrsnt.pos.data.LoginRequest

// Image Loading
import coil.compose.AsyncImage

// ==========================================
// 1. DATA MODELS (CartEntry is specific to UI)
// ==========================================
data class CartEntry(
    val id: String = java.util.UUID.randomUUID().toString(),
    val menuItem: MenuItem,
    val selectedOptionIds: List<Int>,
    val selectedOptionNames: List<String>,
    val finalPrice: Double,
    var quantity: Int
)

// ==========================================
// 2. VIEWMODEL
// ==========================================
class MenuViewModel(application: Application) : AndroidViewModel(application) {

    // --- LOGIN STATE ---
    var isLoggedIn = mutableStateOf(false)
    var currentWaiterId = mutableStateOf<Int?>(null)
    var currentWaiterName = mutableStateOf("")

    // --- APP STATE ---
    var currentScreen = mutableStateOf("TABLES")
    var selectedTable = mutableStateOf<Table?>(null)
    var tables = mutableStateOf<List<Table>>(listOf())
    var categories = mutableStateOf<List<Category>>(listOf())
    var cart = mutableStateListOf<CartEntry>()

    var selectedCategoryIndex = mutableIntStateOf(0)
    var isLoading = mutableStateOf(false)
    var errorMessage = mutableStateOf("")

    private val repository: MenuRepository
    
    // !!! ENSURE THIS MATCHES YOUR DJANGO "Restaurant" UUID !!!
    val RESTAURANT_ID = "a868c506-79b7-4627-b8f8-3e194f212ccd"

    val cartTotal: Double get() = cart.sumOf { it.finalPrice * it.quantity }

    val displayedCategories: List<Category> get() {
        if (categories.value.isEmpty()) return emptyList()
        if (selectedCategoryIndex.intValue == 0) return categories.value
        val actualIndex = selectedCategoryIndex.intValue - 1
        if (actualIndex < categories.value.size) return listOf(categories.value[actualIndex])
        return emptyList()
    }

    init {
        val db = AppDatabase.getDatabase(application)
        repository = MenuRepository(db)
    }

    // --- LOGIN LOGIC ---
    fun login(pin: String) {
        viewModelScope.launch {
            isLoading.value = true
            errorMessage.value = ""
            try {
                val response = RetrofitInstance.api.loginWaiter(LoginRequest(pin, RESTAURANT_ID))
                currentWaiterId.value = response.waiter_id
                currentWaiterName.value = response.waiter_name
                isLoggedIn.value = true
                Toast.makeText(getApplication(), "Welcome, ${response.waiter_name}!", Toast.LENGTH_SHORT).show()
                loadTables()
            } catch (e: Exception) {
                errorMessage.value = "Invalid PIN"
                Log.e("LOGIN", "Error", e)
            } finally {
                isLoading.value = false
            }
        }
    }

    fun logout() {
        isLoggedIn.value = false
        currentWaiterId.value = null
        cart.clear()
        selectedTable.value = null
        currentScreen.value = "TABLES"
    }

    fun loadTables() {
        viewModelScope.launch {
            isLoading.value = true
            try {
                tables.value = RetrofitInstance.api.getTables(RESTAURANT_ID)
                errorMessage.value = ""
            } catch (e: Exception) {
                errorMessage.value = "Error loading tables: ${e.message}"
            } finally {
                isLoading.value = false
            }
        }
    }

    fun selectTable(table: Table) {
        selectedTable.value = table
        currentScreen.value = "MENU"
        loadMenu()
    }

    fun goBackToTables() {
        currentScreen.value = "TABLES"
        selectedTable.value = null
        selectedCategoryIndex.intValue = 0
        cart.clear()
        loadTables()
    }

    fun loadMenu() {
        viewModelScope.launch {
            isLoading.value = true
            // 1. Load Offline Data first
            val offlineData = repository.getMenu()
            if (offlineData.isNotEmpty()) categories.value = offlineData
            
            // 2. Try to Sync
            try {
                categories.value = repository.refreshMenu(RESTAURANT_ID)
            } catch (e: Exception) {
                Log.e("POS", "Sync Error", e)
                if (categories.value.isEmpty()) {
                     errorMessage.value = "Cannot load menu. Check internet."
                }
            } finally {
                isLoading.value = false
            }
        }
    }

    fun addToCart(item: MenuItem, optionIds: List<Int>, optionNames: List<String>, price: Double) {
        val existing = cart.find { it.menuItem.id == item.id && it.selectedOptionIds == optionIds }
        if (existing != null) {
            // Update existing entry
            existing.quantity += 1
            // Trigger recomposition manually for MutableStateList if needed, 
            // but replacing the item usually works best
            val index = cart.indexOf(existing)
            cart[index] = existing.copy()
        } else {
            cart.add(CartEntry(
                menuItem = item, 
                selectedOptionIds = optionIds, 
                selectedOptionNames = optionNames, 
                finalPrice = price, 
                quantity = 1
            ))
        }
    }

    fun updateCartEntry(oldEntry: CartEntry, newOptionIds: List<Int>, newOptionNames: List<String>, newPrice: Double) {
        cart.remove(oldEntry)
        // Add as new item (merging if identical exists)
        addToCart(oldEntry.menuItem, newOptionIds, newOptionNames, newPrice)
    }

    fun removeFromCart(entry: CartEntry) {
        cart.remove(entry)
    }

    fun placeOrder() {
        if (cart.isEmpty()) return

        viewModelScope.launch {
            isLoading.value = true
            try {
                val orderItems = cart.map { entry ->
                    OrderItemRequest(entry.menuItem.id, entry.quantity, entry.selectedOptionIds)
                }
                
                val request = OrderRequest(
                    restaurant_id = RESTAURANT_ID,
                    table_id = selectedTable.value!!.id,
                    waiter_id = currentWaiterId.value,
                    items = orderItems
                )
                
                RetrofitInstance.api.createOrder(request)
                
                // --- FIX: VISUAL CONFIRMATION ---
                Toast.makeText(getApplication(), "✅ Order Sent to Kitchen!", Toast.LENGTH_LONG).show()
                
                goBackToTables()
            } catch (e: Exception) {
                errorMessage.value = "Order Failed: ${e.message}"
                Toast.makeText(getApplication(), "❌ Order Failed!", Toast.LENGTH_LONG).show()
            } finally {
                isLoading.value = false
            }
        }
    }
}

// ==========================================
// 3. UI SCREENS
// ==========================================
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            // Updated Material3 Theme wrapper
            MaterialTheme {
                Surface(color = Color(0xFFF5F5F5), modifier = Modifier.fillMaxSize()) {
                    AppNavigation()
                }
            }
        }
    }
}

@Composable
fun AppNavigation(viewModel: MenuViewModel = viewModel()) {
    if (!viewModel.isLoggedIn.value) {
        LoginScreen(viewModel)
    } else {
        val screen by remember { viewModel.currentScreen }
        if (screen == "TABLES") TableSelectionScreen(viewModel) else MenuScreen(viewModel)
    }
}

@Composable
fun LoginScreen(viewModel: MenuViewModel) {
    var pin by remember { mutableStateOf("") }
    val isLoading by remember { viewModel.isLoading }
    val error by remember { viewModel.errorMessage }

    Box(modifier = Modifier.fillMaxSize().background(Color(0xFF333333)), contentAlignment = Alignment.Center) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text("NEXUS POS", color = Color.White, fontSize = 32.sp, fontWeight = FontWeight.Bold)
            Text("Enter Waiter PIN", color = Color.Gray, modifier = Modifier.padding(bottom = 32.dp))
            
            // PIN Display
            Text(
                text = "* ".repeat(pin.length), 
                color = Color.White, 
                fontSize = 40.sp, 
                fontWeight = FontWeight.Bold, 
                modifier = Modifier.height(50.dp)
            )
            
            Spacer(modifier = Modifier.height(32.dp))
            
            if (error.isNotEmpty()) {
                Text(error, color = Color.Red, modifier = Modifier.padding(bottom = 16.dp))
            }

            if (isLoading) {
                CircularProgressIndicator(color = Color.White)
            } else {
                LazyVerticalGrid(
                    columns = GridCells.Fixed(3), 
                    modifier = Modifier.width(300.dp), 
                    verticalArrangement = Arrangement.spacedBy(16.dp), 
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    items((1..9).toList()) { number -> 
                        PinButton(number.toString()) { if (pin.length < 4) pin += number.toString() } 
                    }
                    item { Spacer(modifier = Modifier.size(1.dp)) }
                    item { PinButton("0") { if (pin.length < 4) pin += "0" } }
                    item { 
                        Button(
                            onClick = { pin = "" }, 
                            colors = ButtonDefaults.buttonColors(containerColor = Color.Red), 
                            modifier = Modifier.size(80.dp), 
                            shape = RoundedCornerShape(50)
                        ) { 
                            Icon(Icons.Default.Clear, contentDescription = null, tint = Color.White) 
                        } 
                    }
                }
            }
            
            // Auto-submit when 4 digits entered
            LaunchedEffect(pin) { 
                if (pin.length == 4) { 
                    viewModel.login(pin)
                    pin = "" 
                } 
            }
        }
    }
}

@Composable
fun PinButton(text: String, onClick: () -> Unit) {
    Button(
        onClick = onClick, 
        colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF444444)), 
        modifier = Modifier.size(80.dp), 
        shape = RoundedCornerShape(50)
    ) {
        Text(text, fontSize = 24.sp, color = Color.White, fontWeight = FontWeight.Bold)
    }
}

@Composable
fun TableSelectionScreen(viewModel: MenuViewModel) {
    val tables by remember { viewModel.tables }
    val isLoading by remember { viewModel.isLoading }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp), 
                horizontalArrangement = Arrangement.SpaceBetween, 
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text("Select Table", fontSize = 28.sp, fontWeight = FontWeight.Bold)
                TextButton(onClick = { viewModel.logout() }) { Text("Logout", color = Color.Red) }
            }
            
            if (tables.isEmpty() && !isLoading) {
                 Text("No tables found. Check connection.", color = Color.Gray)
            }

            LazyVerticalGrid(
                columns = GridCells.Fixed(3), 
                horizontalArrangement = Arrangement.spacedBy(12.dp), 
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                items(tables) { table ->
                    Card(
                        colors = CardDefaults.cardColors(containerColor = if (table.is_occupied) Color(0xFFFFEBEE) else Color.White), 
                        elevation = CardDefaults.cardElevation(4.dp), 
                        modifier = Modifier
                            .height(100.dp)
                            .clickable { viewModel.selectTable(table) }
                    ) {
                        Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(
                                    table.name, 
                                    fontSize = 24.sp, 
                                    fontWeight = FontWeight.Bold, 
                                    color = if(table.is_occupied) Color.Red else Color.Black
                                )
                                if (table.is_occupied) Text("Occupied", fontSize = 12.sp, color = Color.Red)
                            }
                        }
                    }
                }
            }
        }
        
        // Loading Overlay
        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxSize().background(Color.Black.copy(alpha = 0.5f)),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = Color.White)
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MenuScreen(viewModel: MenuViewModel) {
    val displayedCategories = viewModel.displayedCategories
    val allCategories by remember { viewModel.categories }
    val selectedIndex by remember { viewModel.selectedCategoryIndex }
    var showCartSheet by remember { mutableStateOf(false) }
    val table = viewModel.selectedTable.value
    val cartSize = viewModel.cart.sumOf { it.quantity }
    val isLoading by remember { viewModel.isLoading }

    Box(modifier = Modifier.fillMaxSize()) {
        Scaffold(
            topBar = {
                Column {
                    TopAppBar(
                        title = { Text("Ordering for ${table?.name}", fontWeight = FontWeight.Bold) }, 
                        navigationIcon = { Button(onClick = { viewModel.goBackToTables() }) { Text("< Back") } }, 
                        colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.White)
                    )
                    if (allCategories.isNotEmpty()) {
                        CategoryTabs(allCategories, selectedIndex) { viewModel.selectedCategoryIndex.intValue = it }
                    }
                }
            },
            bottomBar = {
                if (cartSize > 0) {
                    Surface(
                        color = Color(0xFF333333), 
                        shadowElevation = 12.dp, 
                        modifier = Modifier.fillMaxWidth().clickable { showCartSheet = true }
                    ) {
                        Row(
                            modifier = Modifier.padding(16.dp), 
                            horizontalArrangement = Arrangement.SpaceBetween, 
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column { 
                                Text("Total: ₹${viewModel.cartTotal}", color = Color.Green, fontSize = 18.sp, fontWeight = FontWeight.Bold)
                                Text("$cartSize Items (Tap to View)", color = Color.LightGray, fontSize = 12.sp) 
                            }
                            Button(
                                onClick = { viewModel.placeOrder() }, 
                                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF006CFA)),
                                enabled = !isLoading // Disable button while loading
                            ) { 
                                Text("Place Order") 
                            }
                        }
                    }
                }
            }
        ) { padding ->
            LazyColumn(contentPadding = padding, modifier = Modifier.padding(16.dp)) {
                items(displayedCategories) { category -> CategorySection(category, viewModel) }
            }
        }
        
        // --- FIX: Loading Overlay to prevent double clicks ---
        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxSize().background(Color.Black.copy(alpha = 0.5f)).clickable(enabled = false) {}, // Block touches
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator(color = Color.White)
                    Spacer(modifier = Modifier.height(16.dp))
                    Text("Processing Order...", color = Color.White, fontWeight = FontWeight.Bold)
                }
            }
        }
    }
    
    if (showCartSheet) {
        ModalBottomSheet(onDismissRequest = { showCartSheet = false }) { 
            CartBottomSheetContent(viewModel) { showCartSheet = false } 
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CartBottomSheetContent(viewModel: MenuViewModel, onClose: () -> Unit) {
    var entryToEdit by remember { mutableStateOf<CartEntry?>(null) }
    
    Column(modifier = Modifier.padding(16.dp).fillMaxHeight(0.5f)) {
        Text("Your Cart", fontSize = 24.sp, fontWeight = FontWeight.Bold, modifier = Modifier.padding(bottom = 16.dp))
        
        LazyColumn(modifier = Modifier.weight(1f)) {
            items(items = viewModel.cart, key = { it.id }) { entry ->
                val dismissState = rememberSwipeToDismissBoxState(
                    confirmValueChange = { 
                        if (it == SwipeToDismissBoxValue.EndToStart) { 
                            viewModel.removeFromCart(entry)
                            true 
                        } else false 
                    }
                )
                
                SwipeToDismissBox(
                    state = dismissState,
                    backgroundContent = {
                        val color by animateColorAsState(if (dismissState.targetValue == SwipeToDismissBoxValue.EndToStart) Color.Red else Color.Transparent)
                        Box(Modifier.fillMaxSize().background(color).padding(horizontal = 20.dp), contentAlignment = Alignment.CenterEnd) { 
                            Icon(Icons.Default.Delete, contentDescription = null, tint = Color.White) 
                        }
                    },
                    content = {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .background(Color.White)
                                .clickable { entryToEdit = entry }
                                .padding(vertical = 12.dp), 
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text("${entry.quantity} x ${entry.menuItem.name}", fontWeight = FontWeight.Bold, fontSize = 16.sp)
                                if (entry.selectedOptionNames.isNotEmpty()) { 
                                    Text(entry.selectedOptionNames.joinToString(", "), color = Color.Gray, fontSize = 14.sp)
                                    Text("Tap to edit options", fontSize = 10.sp, color = Color(0xFF006CFA)) 
                                }
                            }
                            Text("₹${entry.finalPrice * entry.quantity}", fontWeight = FontWeight.Bold)
                        }
                    }
                )
                Divider(color = Color(0xFFEEEEEE))
            }
        }
    }
    
    if (entryToEdit != null) {
        VariantSheet(
            item = entryToEdit!!.menuItem, 
            initialSelectionIds = entryToEdit!!.selectedOptionIds, 
            onDismiss = { entryToEdit = null }, 
            onAddToCart = { ids, names, price -> 
                viewModel.updateCartEntry(entryToEdit!!, ids, names, price)
                entryToEdit = null 
            }
        )
    }
}

@Composable
fun CategoryTabs(categories: List<Category>, selectedIndex: Int, onSelect: (Int) -> Unit) {
    val tabNames = listOf("All Items") + categories.map { it.name }
    LazyRow(modifier = Modifier.fillMaxWidth().background(Color.White).padding(12.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
        itemsIndexed(tabNames) { index, name ->
            val isSelected = index == selectedIndex
            Box(
                modifier = Modifier
                    .background(if (isSelected) Color(0xFF006CFA) else Color(0xFFF0F0F0), RoundedCornerShape(50))
                    .clickable { onSelect(index) }
                    .padding(horizontal = 20.dp, vertical = 10.dp)
            ) { 
                Text(name, color = if (isSelected) Color.White else Color.Black, fontWeight = FontWeight.Bold) 
            }
        }
    }
}

@Composable
fun CategorySection(category: Category, viewModel: MenuViewModel) {
    Column(modifier = Modifier.padding(vertical = 8.dp)) {
        Text(category.name, fontSize = 20.sp, fontWeight = FontWeight.SemiBold, color = Color(0xFF006CFA))
        category.menu_items.forEach { menuItem -> MenuItemCard(menuItem, viewModel) }
    }
}

@Composable
fun MenuItemCard(item: MenuItem, viewModel: MenuViewModel) {
    var showSheet by remember { mutableStateOf(false) }
    val quantity = viewModel.cart.filter { it.menuItem.id == item.id }.sumOf { it.quantity }
    
    // --- FIX: Use helper function for images ---
    val imageUrl = fixImageUrl(item.image)
    
    Card(
        colors = CardDefaults.cardColors(containerColor = Color.White), 
        elevation = CardDefaults.cardElevation(4.dp), 
        shape = RoundedCornerShape(12.dp), 
        modifier = Modifier.fillMaxWidth().padding(bottom = 12.dp)
    ) {
        Row(modifier = Modifier.padding(12.dp), verticalAlignment = Alignment.CenterVertically) {
            if (imageUrl != null) {
                AsyncImage(
                    model = imageUrl, 
                    contentDescription = null, 
                    modifier = Modifier.size(80.dp).background(Color.LightGray, RoundedCornerShape(8.dp)), 
                    contentScale = ContentScale.Crop
                )
            } else {
                Box(modifier = Modifier.size(80.dp).background(Color(0xFFEEEEEE), RoundedCornerShape(8.dp)), contentAlignment = Alignment.Center) { 
                    Text("No Img", fontSize = 10.sp) 
                }
            }
            
            Column(modifier = Modifier.weight(1f).padding(horizontal = 12.dp)) {
                Text(item.name, fontSize = 18.sp, fontWeight = FontWeight.Bold)
                if(!item.description.isNullOrEmpty()) {
                    Text(item.description, fontSize = 12.sp, color = Color.Gray, maxLines = 1)
                }
                Text("₹${item.price}", fontSize = 16.sp, color = Color(0xFF4CAF50))
            }
            
            Button(
                onClick = { 
                    if (item.variant_groups.isNotEmpty()) showSheet = true 
                    else viewModel.addToCart(item, emptyList(), emptyList(), item.price) 
                }, 
                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFFFF0F0)), 
                shape = RoundedCornerShape(50), 
                modifier = Modifier.height(36.dp)
            ) { 
                Text(if (quantity > 0) "+$quantity" else "ADD", color = Color(0xFFFF4040), fontWeight = FontWeight.Bold) 
            }
        }
    }
    if (showSheet) {
        VariantSheet(item, emptyList(), { showSheet = false }, { ids, names, price -> viewModel.addToCart(item, ids, names, price) })
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun VariantSheet(item: MenuItem, initialSelectionIds: List<Int>, onDismiss: () -> Unit, onAddToCart: (List<Int>, List<String>, Double) -> Unit) {
    val selections = remember { mutableStateMapOf<Int, List<Int>>() }
    
    LaunchedEffect(Unit) {
        item.variant_groups.forEach { group ->
            val selectedInGroup = group.options.map { it.id }.filter { it in initialSelectionIds }
            if (selectedInGroup.isNotEmpty()) selections[group.id] = selectedInGroup
        }
    }
    
    val addedPrice = item.variant_groups.flatMap { g -> 
        g.options.filter { it.id in (selections[g.id] ?: emptyList()) } 
    }.sumOf { it.price_adjustment }
    
    val totalPrice = item.price + addedPrice

    ModalBottomSheet(onDismissRequest = onDismiss) {
        Column(modifier = Modifier.padding(16.dp).verticalScroll(rememberScrollState())) {
            Text(if(initialSelectionIds.isEmpty()) "Customize Order" else "Edit Order", fontSize = 24.sp, fontWeight = FontWeight.Bold)
            
            item.variant_groups.forEach { group ->
                Text(group.name + if(group.is_required) "*" else "", fontWeight = FontWeight.Bold, modifier = Modifier.padding(vertical = 8.dp))
                group.options.forEach { option ->
                    val isSelected = selections[group.id]?.contains(option.id) == true
                    Row(
                        modifier = Modifier.fillMaxWidth().clickable {
                            val currentList = selections[group.id]?.toMutableList() ?: mutableListOf()
                            if (group.allow_multiple) { 
                                if (isSelected) currentList.remove(option.id) else currentList.add(option.id) 
                            } else { 
                                currentList.clear()
                                currentList.add(option.id) 
                            }
                            selections[group.id] = currentList.toList()
                        }.padding(vertical = 12.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        val icon = if(isSelected) Icons.Default.Check else Icons.Default.Clear
                        val tint = if(isSelected) Color(0xFF006CFA) else Color.LightGray
                        Icon(icon, null, tint = tint, modifier = Modifier.size(24.dp))
                        Text(option.name, modifier = Modifier.padding(start = 12.dp).weight(1f))
                        if(option.price_adjustment != 0.0) {
                            Text((if(option.price_adjustment > 0) "+" else "") + "₹${option.price_adjustment}", color = Color.Gray)
                        }
                    }
                    Divider(color = Color(0xFFEEEEEE))
                }
            }
            
            Button(
                onClick = { 
                    val allRequiredMet = item.variant_groups.all { !it.is_required || (selections[it.id]?.isNotEmpty() == true) }
                    if(allRequiredMet) { 
                        val selectedNames = item.variant_groups.flatMap { g -> 
                            g.options.filter { it.id in (selections[g.id] ?: emptyList()) }.map { it.name } 
                        }
                        onAddToCart(selections.values.flatten(), selectedNames, totalPrice)
                        onDismiss() 
                    } else {
                        // Could add a small toast here too "Please select required items"
                    }
                }, 
                modifier = Modifier.fillMaxWidth().padding(vertical = 24.dp), 
                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF006CFA))
            ) { 
                Text(if(initialSelectionIds.isEmpty()) "Add Item - ₹$totalPrice" else "Update Item - ₹$totalPrice") 
            }
        }
    }
}

// --- HELPER FOR IMAGE URLs ---
fun fixImageUrl(url: String?): String? {
    if (url == null) return null
    if (url.startsWith("http")) {
        // Replace localhost with Android Emulator loopback IP
        return url.replace("127.0.0.1", "10.0.2.2")
    }
    // Handle relative paths (e.g. /media/menu_images/...)
    if (url.startsWith("/")) {
        return "http://10.0.2.2:8000$url"
    }
    return url
}